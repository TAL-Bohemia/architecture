# 单元测试规范

## 1 目的

单元测试是编写测试代码，用来检测特定的、明确的、细颗粒的功能。单元测试不仅仅用来保证当前代码的正确性，更重要的是用来保证代码**修复**、**改进**或**重构**之后的正确性。

单元测试的目的主要有三方面：

1) 验证单元代码和详细设计文档的一致性;

2) 跟踪详细设计文档中设计的实现，发现详细设计文档中存在的错误;

3) 发现在编码过程中引入的错误(编码过程中引入的错误包含两类:和设计不符引入的错误;和设计相符但由于编码出现疏漏导致错误),这里其实是针对文档和代码是否一致的测试。

## 2 适用范围

单元测试首先应当是自动化的，由开发人员编写，为了保证代码片段（最小单元）是按照预期设计实现的。单元测试要保障的是项目（代码片段逻辑）自身按照设计意图正确执行，所以单元测试的范围仅限于单个项目内部，因此要尽量屏蔽所有的外部系统或中间件。核心代码的语句覆盖达到50%以上，其他部分（工具类等）不做要求。

## 3 单元测试

### 3.1 单元测试原则

1、对全新的代码或核心的代码进行测试；

2、单元测试根据计划进行，排除测试的随意性；

3、当计划中的结束标准达到时，单元测试才能结束；

4、对被测试单元需达到一定的代码覆盖率要求。

### 3.2 单元测试策略

一般的单元测试策略有3种：独立的单元测试、自上向下的单元测试、自下向上的单元测试。

1、独立的单元测试

- 方法：不考虑每个模块与其他模块之间的关系，为每个模块设计桩模块和驱动模块。每个模块进行独立的单元测试。
- 优点：最简单，最容易操作; 可以达到高的结构覆盖率；可以并行开展。
- 缺点：桩函数和驱动函数工作量很大，效率低。

2、自上向下的单元测试

- 方法：先对最顶层的单元进行测试，把顶层所调用的单元做成桩模块；对第二层进行测试，使用上面已测试的单元做驱动模块，以此类推直到测试完所有模块。
- 优点：可以节省驱动函数的开发工作量，测试效率较高。
- 缺点：随着被测单元一个一个被加入，测试过程将变得越来越复杂，并且开发和维护的成本将增加。

3、自下向上的单元测试

- 方法：先对模块调用层次图上最底层的模块进行单元测试，模拟调用该模块的模块做驱动模块；然后再对上面一层做单元测试，用下面已被测试过的模块做桩模块，以此类推直到测试完所有模块。
- 优点：可以节省桩函数的开发工作量，测试效率较高。
- 缺点：不是纯粹的单元测试，底层函数的测试质量对上层函数的测试将产生很大的影响。

### 3.3 单元测试环境

在单元测试时，由于单元本身不是一个独立的程序，一个完整的可运行的软件系统并未构成，所以需要设置一些辅助测试单元，辅助测试单元有两种：驱动单元和桩单元。

1、驱动单元

用来模拟被测试单元的上层单元，相当于被测函数的主程序，它接收测试数据，将相关数据传送到被测单元，启动被测单元，最后再输出实测结果。当被测单元能完成相关功能时，也可以不要驱动单元。

驱动单元主要完成以下几个步骤：

1) 接受测试数据，包含测试用例的输入和预期输入；

2) 把测试用例输入传送给要测试的单元，驱动被测单元执行；

3) 将被测单元的实际输出和预期输出进行比较，得到测试结果；

4) 将测试结果输出到指定位置。

2、桩单元

用来代替被测单元工作过程中调用的子单元，桩单元的功能是从测试角度模拟被测单元所调用的其他单元，桩单元需要针对不同的输入，返回不同的期望值，模拟不同的功能。如果被测单元为底层函数吗，则不需要设计桩单元。

桩单元的类型：系统函数、自定义函数（可能存在错误，会影响测试结果，给分析被测单元造成困难，因此需要构造正确无误的桩单元来达到隔离的目的）。

3、构造单元的测试环境的主要工作

1) 构造最小运行调度系统，即驱动单元，用以模拟被测单元的上一级单元;

2) 模拟实现单元接口，即单元函数需调用的其他函数接口，即桩单元;

3) 模拟生成测试数据和状态，为单元运行准备动态环境。

### 3.4 单元测试工具（根据开发语言选择，不限制具体使用情况）

1、代码静态分析工具

2、代码检查工具

3、测试脚本工具

4、覆盖率检测工具

5、内存检测工具

6、专为单元测试设计的工具



